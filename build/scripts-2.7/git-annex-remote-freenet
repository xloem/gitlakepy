#!/usr/bin/python2

import sys
from gitlake import GitAnnexESRP

try:
  import fcp
except:
  GitAnnexESRP().ERROR("** PyFreenet core module 'fcp' not installed.")
  sys.exit(1)


argv = sys.argv
argc = len(argv)
progname = argv[0]

class FreenetRemote(GitAnnexESRP):
  def __init__(self):
    self.node = None
    GitAnnexESRP.__init__(self)

  # create new special remote, may be called repeatedly on the same remote,
  # or not at all if the remote has already been configured
  # usually uses SETCONFIG, SETCREDS
  def initRemote(self):
    if self.GETCONFIG('priority') == '':
      self.SETCONFIG('priority', 0)

  # activate remote, called once at start
  # query configuration with GETCONFIG, GETCREDS
  def prepare(self):
    self.node = fcp.node.FCPNode(name = 'git-annex-' + self.GETUUID(),
                                 logfunc = lambda msg: self.DEBUG(msg),
                                 verbosity = 5)
    self.jobsTicket = self.node.refreshPersistentRequests(async=True);

  # return False or True if key is present
  def isPresent(self,key):
    for url in self.GETURLS(key, "freenet:"):
      try:
        self.node.get(
          url,
          nodata = True,
          ignoreds = True,
          priority = self.GETCONFIG('priority')
        )
        return True
      except Exception:
        pass
    return False

  # store file in key
  def store(self,key,filename):
    ticket = None
    uri = 'CHK@'
    state = self.GETSTATE(key)
    if state != '':
      if state[0:2] == 'id':
        self.jobsTicket.wait()
        for job in self.node.getAllJobs():
          if job.id == state:
            ticket = job
      else:
        uri = state
    if ticket == None:
      data = file(filename,'rb').read()
      size = len(data)
      ticket = self.node.put(
        data = data,
        name = key,
        uri = uri,
        persistence = 'reboot',
        async = True,
        waituntilsent = True,
        Verbosity = 9,
        priority = self.GETCONFIG('priority'),
        callback = lambda status, value: self.fcpCallback(key, size, status, value)
      )
      self.SETSTATE(key, ticket.id)
      data = ""
    try:
      uri = ticket.uri
    except:
      pass
    uri = ticket.wait()
    self.SETSTATE(key, uri)
    self.SETURIPRESENT(key, 'freenet:' + uri)

  def fcpCallback(self, key, size, status, value):
    self.DEBUG(status + ': '  + repr(value))
    if status == "pending":
      if value['header'] == "SimpleProgress":
        self.PROGRESS(int(size / float(value['Required']) * float(value['Succeeded'])))
      elif value['header'] == 'URIGenerated':
        uri = value['URI']
        self.SETURIPRESENT(key, 'freenet:' + uri)
      elif value['header'] == 'ExpectedHashes':
        # if the key happens to be SHA256, we can quickly verify the data is not corrupt against the key
        try:
          hash = value['Hashes.SHA256']
          if key[:6] == 'SHA256' and key[-len(hash):] != hash:
            raise Exception('sha256 mismatch %s is not %s' % { hash, key })
        except KeyError:
          pass
    elif status == "successful":
      self.PROGRESS(size)
    

  # return True if responsible for downloading passed url
  def claimsUrl(self, url):
    return url[0:8] == 'freenet:'

  # return a list of (url, size, filename) that may currently be
  # downloaded from the provided url
  # size may be None if unknown
  # return empty list if cannot currently download url
  def checkUrl(self, url):
    try:
      self.node.get(
        url,
        nodata = True,
        priority = self.GETCONFIG('priority')
      )
      return [url,None,'']
    except:
      return []

  # retrieve key to file
  def retrieve(self, key, filename):
    # TODO: this uses GETSTATE, but isPresent uses GETURLS
    #       could lead to inconsistent state
    # TODO: send progress messages for all long-running tasks
    self.node.get(
      self.GETSTATE(key),
      stream = file(filename,'wb'),
      priority = self.GETCONFIG('priority')
    )

  # connection closed, deactivate remote if activated
  def finish(self):
    if self.node != None:
      self.node.shutdown()
      

FreenetRemote()
